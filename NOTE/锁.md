
![[Java中锁的分类.png]]
## 使用乐观锁(CAS)还是悲观锁(synchronized)
各有优缺点，所以分情况。
- **悲观锁** 适合 **写操作多** 的场景，先加锁可以保证写操作时数据正确。
- **乐观锁** 适合 **读操作多** 的场景，不加锁的特点能够使其读操作的性能大幅提升，常采用的是***CAS算法***。

### CAS (Compare and swap)
1. **什么是CAS(Compare and swap)比较并交换 ，一种无锁算法 **
	CAS机制当中使用了3个基本操作数：
	- 需要读写的内存值 V，
	- 进行比较的值 A，
	- 要写入的新值 B。
当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。

2. **CAS虽然很高效，但是它也存在三大问题：**  
	1. **ABA问题**。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。
		- JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。 
	1. **循环时间长开销大**。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。  
	2. **只能保证一个共享变量的原子操作**。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。
		- Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。

## 自旋锁 VS 适应性自旋锁

## 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁
这四种锁的状态是专门针对`synchronized`的。
### Java对象头
对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）
- **Mark Word: **默认存储对象的HashCode，分代年龄和锁标志位信息。
- **Klass Pointer:**对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

### Monitor
Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。
Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时**monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用**。

synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的。
**synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。**
jdk6之前，synchronized依靠Mutex Lock实现，会导致阻塞或唤醒线程，导致cpu上下文切换耗费大量性能。为了减少这些性能消耗，jdk1.6中引入 偏向锁、轻量级锁，因此现在锁一共有4中状态：`无锁`、 `偏向锁` 、 `轻量级锁` 、 `重量级锁`。
锁的状态只能升，不能降。`无锁 - > 偏向锁 - > 轻量级锁 - > 重量级锁 `
- **无锁：**
无锁就是没有对资源锁定。所有线程都能访问资源，但只能一个线程修改成功。CAS就是一种无锁算法，无锁的实现。
- **偏向锁：**
	- 在大多数情况下，锁总是由同一线程多次获得，偏向锁就是一段同步代码一直被同一个线程访问，那么该线程就自动获取锁，降低获取锁的代价。
	- 一个线程在没有竞争的进入同步代码块后，该线程会自动获取锁，在`Mark Word`中存储线程id，在该线程之后的进入退出同步代码块时，不用再通过CAS操作来加锁解锁，而是检测`Mark Word`中是否存储着当前线程id。引入偏向锁就是为了减少轻量级锁的CAS原子指令。
	- 当偏向锁状态时，有其他线程加入竞争，则升级为轻量级锁。
- **轻量级锁：**
	- 当锁状态从，偏向锁升级为轻量级锁时，新参与竞争的锁会通过自旋的形式尝试获取锁，不会阻塞。
	- 若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。
- **重量级锁：**
升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。

综上，
1. 偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。
2. 而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。
3. 重量级锁是将除了拥有锁的线程以外的线程都阻塞。

## 公平锁 VS 非公平锁

## 可重入锁 VS 非可重入锁

## 独享锁 VS 共享锁

[[参考链接#不可不说的Java“锁”事 https tech meituan com 2018 11 15 java-lock html|不可不说的Java“锁”事]]