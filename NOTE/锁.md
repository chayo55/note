
![[Java中锁的分类.png]]
## 使用乐观锁(CAS)还是悲观锁(synchronized)
各有优缺点，所以分情况。
- **悲观锁** 适合 **写操作多** 的场景，先加锁可以保证写操作时数据正确。
- **乐观锁** 适合 **读操作多** 的场景，不加锁的特点能够使其读操作的性能大幅提升，常采用的是***CAS算法***。

### CAS (Compare and swap)
1. **什么是CAS(Compare and swap)比较并交换 ，一种无锁算法 **
	CAS机制当中使用了3个基本操作数：
	- 需要读写的内存值 V，
	- 进行比较的值 A，
	- 要写入的新值 B。
当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。

2. **CAS虽然很高效，但是它也存在三大问题：**  
	1. **ABA问题**。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。
		- JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。 
	1. **循环时间长开销大**。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。  
	2. **只能保证一个共享变量的原子操作**。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。
		- Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。

## 自旋锁 VS 适应性自旋锁

## 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁
这四种锁的状态是专门针对`synchronized`的。
### Java对象头
新建一个空对象Object，在Hotspot虚拟机中，占用16字节(byte)。使用jol工具分析可看到：
`Instance size: 16 bytes`
```Java
# Running 64-bit HotSpot VM.
# Using compressed oop with 3-bit shift.
# Using compressed klass with 3-bit shift.
# Objects are 8 bytes aligned.
# Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]
# Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]

java.lang.Object object internals:
 OFFSET  SIZE   TYPE DESCRIPTION        VALUE
      0     4        (object header)    01 00 00 00 (00000001 00000000 00000000 00000000) (1)
      4     4        (object header)    00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)    e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
```

对象内存布局结构：
![[对象内存布局的结构.jpg]]


对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）
- **Mark Word: *****默认***存储对象的HashCode，分代年龄和锁标志位信息。
- **Klass Pointer:**对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

JVM一般是这样使用锁和**Mark Word**的：

1，当没有被当成锁时，这就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否偏向锁那一位是0。

2，当对象被当做同步锁并有一个线程A抢到了锁时，锁标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程id，表示进入偏向锁状态。

3，当线程A再次试图来获得锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程id就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码。

4，当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁，这里的获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5。

5，偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在当前线程的线程栈中开辟一块单独的空间，里面保存指向对象锁Mark Word的指针，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6。

6，轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7。

7，自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞。

### Monitor
Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。
Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时**monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用**。

synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的。
**synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。**
jdk6之前，synchronized依靠Mutex Lock实现，会导致阻塞或唤醒线程，导致cpu上下文切换耗费大量性能。为了减少这些性能消耗，jdk1.6中引入 偏向锁、轻量级锁，因此现在锁一共有4中状态：`无锁`、 `偏向锁` 、 `轻量级锁` 、 `重量级锁`。
锁的状态只能升，不能降。`无锁 - > 偏向锁 - > 轻量级锁 - > 重量级锁 `
- **无锁：**
无锁就是没有对资源锁定。所有线程都能访问资源，但只能一个线程修改成功。CAS就是一种无锁算法，无锁的实现。
- **偏向锁：**
	- 在大多数情况下，锁总是由同一线程多次获得，偏向锁就是一段同步代码一直被同一个线程访问，那么该线程就自动获取锁，降低获取锁的代价。
	- 一个线程在没有竞争的进入同步代码块后，该线程会自动获取锁，在`Mark Word`中存储线程id，在该线程之后的进入退出同步代码块时，不用再通过CAS操作来加锁解锁，而是检测`Mark Word`中是否存储着当前线程id。引入偏向锁就是为了减少轻量级锁的CAS原子指令。
	- 当偏向锁状态时，有其他线程加入竞争，则升级为轻量级锁。
- **轻量级锁：**
	- 当锁状态从，偏向锁升级为轻量级锁时，新参与竞争的锁会通过自旋的形式尝试获取锁，不会阻塞。
	- 若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。
- **重量级锁：**
升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。

综上，
1. 偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。
2. 而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。
3. 重量级锁是将除了拥有锁的线程以外的线程都阻塞。

## 公平锁 VS 非公平锁
公平锁和非公平锁。何谓公平性，是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足FIFO。
1. 公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源时间上的绝对顺序，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，造成“饥饿”现象。
2. 公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，`ReentrantLock`默认选择的是非公平锁，则是为了减少一部分上下文切换，保证了系统更大的吞吐量。
	```Java
	public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
	```


## 可重入锁 VS 非可重入锁

## 独享锁 VS 共享锁

[[参考链接#不可不说的Java“锁”事 https tech meituan com 2018 11 15 java-lock html|不可不说的Java“锁”事]]