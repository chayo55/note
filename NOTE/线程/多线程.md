## 线程
### 线程的基本状态
1. new 新建
2. runnable 可运行状态
3. running 运行时
4. block 阻塞
	- 等待阻塞：	运行running 的线程执行 wait() 方法，[[JVM]]会将该线程放入等待队列wait queue
	- 同步阻塞： 运行(running)的线程获取[[锁]] synchronized 时，若该锁被别的线程占用,则JVM会把该线程放入锁池(lock pool)中
	- 其他阻塞： 运行(running)的线程执行 sleep(long ms)或 t2.join()方法，或有I/O请求，JVM将当前线程设为阻塞。sleep()超时，join()的等待线程结束或终止，I/O请求结束，恢复该线程
5. dead 死亡

### sleep()、yield()、wait()、join()的区别
1. `sleep()`：Thread类的方法，必须带一个时间参数。会让当前线程休眠进入阻塞状态并释放CPU（阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段），提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁  可通过调用interrupt()方法来唤醒休眠线程。
2. `yield()`：让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 ，并且yield()方法只能让同优先级的线程有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。
3. `wait()`：Object类的方法(notify()、notifyAll()  也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁
4. `join()`：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。

状态间转换图示：
![[线程的基本状态.png]]
### *synchronized*
**`synchronized是托管给JVM执行的`**
`synchronized`会被拆分成`monitorenter`和`monitorexit`两个字节码指令
1. 锁 Class  class锁对类下所有实例作用
2. 锁 代码块 也是class锁
3. 锁 对象  对象锁只对该对象作用
4. notify() 必须在所在代码块执行完后才释放锁
### *Lock*
**`Lock的锁定是通过代码实现的。`**
#### Lock实现类 **ReentrantLock**(排他锁,同一时刻只允许一个线程访问)
- ReentrantReadWriteLock
	内部维护了两个锁，`ReadLock`和`WriteLock`，通过分离读锁和写锁(读锁不互斥，写锁互斥)，提高并发性
- 特性：
	- 公平性选择：
		ReentrantReadWriteLock(boolean fair)
		支持非公平（默认）和公平的锁获取方式，
		吞吐量上来看还是非公平优于公平
	- 重进入：
		该锁支持重进入，以读写线程为例：读线程在获取了读锁之后，能够再次获取读锁。而写线程在获取了写锁之后能够再次获取写锁也能够同时获取读锁
- 使用Condition实现等待/通知机制
	- await()
	- signal() 必须在所在代码块执行完后才释放锁同 notify()类似

### *volatile*
保证了所修饰变量的可见性和有序性
**可见性**：对其他线程可见
**有序性**：指令有序性
但不能保证变量的原子性
例：copyOnWriteArrayList

### *ThreadLocal*
`ThreadLocal`是一个为线程提供线程局部变量的工具类。它的思想也十分简单，就是**为线程提供一个线程私有的变量副本**，这样多个线程都可以随意更改自己线程局部的变量，不会影响到其他线程。不过需要注意的是，**`ThreadLocal`提供的只是一个浅拷贝，如果变量是一个引用类型，那么就要考虑它内部的状态是否会被改变，想要解决这个问题可以通过重写`ThreadLocal`的`initialValue()`函数来自己实现深拷贝**，建议在使用ThreadLocal时一开始就重写该函数。
参考链接：[ThreadLocal](https://juejin.im/post/6844903509037416455#heading-1)


### *多线程开发常见问题：*

- **多线程编程就一定更好更快吗？**
并发编程的目的是提高程序执行效率，但不是总能让程序更快，并发编程可能会遇到很多问题，比如：内存泄漏，上下文切换，死锁，硬件资源限制等

- **上下文切换**
	- CPU同一时间段只能执行一个线程的程序，所以即使多线程同时运行，也是通过给每个线程分配CPU时间片段，
		上下文切换就是指，当前任务执行完切换到另一个任务前会保存任务状态，再次切换回来再加载任务状态，任务状态从保存到再次加载，就是一次上下文切换
	- 如何减少上下文切换？
		1. 减少锁的使用。因为多线程竞争锁时会引起上下文切换。
		2. 使用CAS算法。这种算法也是为了减少锁的使用。CAS算法是一种无锁算法。
		3. 减少线程的使用。人物很少的时候创建大量线程会导致大量线程都处于等待状态。
		4. 使用协程。
			协程： 也可以说是微线程或者说是轻量级的线程，它占用的内存更少并且更灵活。

- **死[[锁]]**
	- 在两个或者两个以上线程中，因为竞争资源，或者由于彼此通信造成阻塞的现象。在线程中，如果两个线程同时等待对方释放锁也会产生死锁。
	- 如何避免死锁？
		1. 避免一个线程同时获得多个锁
		2. 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
		3. 尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制
		4. 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

- **资源限制**
	- 比如CPU，内存，IO，网络等硬件资源限制
	- 解决：
		- 合理使用并发度，比如某资源单线程下载速度是1M/S，网络带宽2M/S，即使开启10个下载线程也无法提供更快的下载速度
		- 对于硬件资源限制，使用集群。既然在单机上受到限制，就在集群上并行执行程序
		- 对于软件资源限制，使用资源池[[线程池#]]，对资源复用

