- **新生代的GC**
	1. 绝大多数刚刚被创建的对象会存放在伊甸园空间(Eden)。
	2. 在伊甸园空间执行了第一次GC之后，存活的对象被移动到其中一个幸存者空间(From Survivor)。
	3. 此后，在伊甸园空间执行GC之后，存活的对象会被堆积在同一个幸存者空间(From Survivor)。
	4.  当一个幸存者空间饱和，还在存活的对象会被移动到另一个幸存者空间(To Survivor)。
	5.  之后会清空已经饱和的那个幸存者空间。(同一时间必有一个幸存者空间为空的)
	6.  在以上的步骤中重复几次依然存活的对象，就会被移动到老年代。
- **老年代GC**，5种GC类型
	1. Serial GC
	2. Parallel GC
	3. Parallel Old GC (Parallel Compacting GC)
	4. Concurrent Mark & Sweep GC  (or “CMS”)
	5. Garbage First (G1) GC

---

### 常见的垃圾回收算法：

1、Mark-Sweep（标记-清除算法）：

（1）思想：标记清除算法分为两个阶段，标记阶段和清除阶段。标记阶段任务是标记出所有需要回收的对象，清除阶段就是清除被标记对象的空间。

（2）优缺点：实现简单，容易产生内存碎片

2、Copying（复制清除算法）：

（1）思想：将可用内存划分为大小相等的两块，每次只使用其中的一块。当进行垃圾回收的时候了，把其中存活对象全部复制到另外一块中，然后把已使用的内存空间一次清空掉。

（2）优缺点：不容易产生内存碎片；可用内存空间少；存活对象多的话，效率低下。

3、Mark-Compact（标记-整理算法）：

（1）思想：先标记存活对象，然后把存活对象向一边移动，然后清理掉端边界以外的内存。

（2）优缺点：不容易产生内存碎片；内存利用率高；存活对象多并且分散的时候，移动次数多，效率低下

4、分代收集算法：（**目前大部分JVM的垃圾收集器所采用的算法**）：

思想：把堆分成新生代和老年代。（永久代指的是方法区）

（1） 因为新生代每次垃圾回收都要回收大部分对象，所以新生代采用Copying算法。新生代里面分成一份较大的Eden空间和两份较小的Survivor空间。每次只使用Eden和其中一块Survivor空间，然后垃圾回收的时候，把存活对象放到未使用的Survivor（划分出from、to）空间中，清空Eden和刚才使用过的Survivor空间。

（2） 由于老年代每次只回收少量的对象，因此采用mark-compact算法。

（3） 在堆区外有一个永久代。对永久代的回收主要是无效的类和常量

5、GC使用时对程序的影响？
垃圾回收会影响程序的性能，Java虚拟机必须要追踪运行程序中的有用对象，然后释放没用对象，这个过程消耗处理器时间

6、几种不同的垃圾回收类型：

（1）Minor GC：从年轻代（包括Eden、Survivor区）回收内存。

A、当JVM无法为一个新的对象分配内存的时候，越容易触发Minor GC。所以分配率越高，内存越来越少，越频繁执行Minor GC
B、执行Minor GC操作的时候，不会影响到永久代（Tenured）。从永久代到年轻代的引用，被当成GC Roots，从年轻代到老年代的引用在标记阶段直接被忽略掉。

（2）Major GC：清理整个老年代，当eden区内存不足时触发。

（3）Full GC：清理整个堆空间，包括年轻代和老年代。当老年代内存不足时触发