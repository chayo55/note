消息队列应用场景：
- 服务解耦：
在服务模块很多的情况下，通过消息队列，使得上游服务不用维护下游服务的调用，只需要把数据交给消息队列，下游服务谁需要谁从消息队列中取。解除了服务间的耦合。

- 流量削峰：
在流量瞬间增大的情况，将服务调用交给消息队列排队处理，可以降低下游服务的瞬时压力

- 异步调用：
在某个调用链路中，如果有个服务的处理时间很长，但结果并不是需要理解返回的，这时就可以把服务调用数据交给消息队列，使得调用链路提前结束，不用阻塞，优化用户体验。而下游耗时服务可以以异步的方式从消息队列接受数据，进行处理。

## RabbitMQ
![[RabbitMQ.png]]

**六种工作模式：**
#### 简单模式
只有一个消费者

#### 工作模式
![[rabbitMQ_工作模式.png]]
工作队列(即任务队列)背后的主要思想是避免立即执行资源密集型任务，并且必须等待它完成。
使用任务队列的一个优点是能够轻松地并行工作。如果我们正在积压工作任务，我们可以添加更多工作进程，这样就可以轻松扩展。

#### 发布订阅模式
![[rabbitMQ_发布和订阅模式.png]]
向多个消费者传递同一条消息。这种模式称为“发布/订阅”。

#### 路由模式
![[rabbitMQ_路由模式.png]]
通过某一特性（routingKey），只订阅所有消息中的一部分。

#### 主题模式
![[rabbitMQ_主题模式.png]]
想接收来自“cron”的关键错误，但也要接收来自“kern”的所有日志时，需要更复杂的Topic交换机。
Topic交换机的消息,它的的routingKey,必须是由点分隔的多个单词。有效的routingKey示例:“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”。
消费者端的bindingKey有两个重要的特殊点:
- `*` 可以通配单个单词。
- `#` 可以通配零个或多个单词。

#### RPC模式
![[rabbitMQ_RPC异步调用模式.png]]
使用rabbitMQ实现一个RPC系统

## RocketMQ
[进阶必看的 RocketMQ ](https://mp.weixin.qq.com/s/Lb1Sm0G0BRofRJ51tpqT1Q)