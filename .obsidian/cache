{"files":{"images/execute方法执行流程图.png":{"mtime":1600444918643.7603,"size":48267,"hash":"da529ea4d3d0416918d143f25b6865531a1199787297508d0ceb049c32f1cb5e"},"images/Executor及其实现类.PNG":{"mtime":1600444918640.8035,"size":11145,"hash":"b15d00672b34f6236cd0f209485b71f06e7e8806822a4f0c8dc60d59c35efd42"},"images/jdk1.8后内存区域图.jpg":{"mtime":1600517412005.408,"size":31274,"hash":"5d54081b4e75d0f4bdc49534028c287761e58239ba8c81654c2c33296e0e6727"},"images/JVM内存区域划分.png":{"mtime":1600444918640.8035,"size":45030,"hash":"562f220865ea6ea0fc35864ee7fbab7495a3f8b24fd1b20fe136c3274347cc78"},"images/shiro授权Authorization流程分析.png":{"mtime":1600517412006.4048,"size":130658,"hash":"0e36384505456f5978a5167ad995d243cf8f9086dc4cd1f310deec5e24688ea0"},"images/shiro核心对象.png":{"mtime":1600517412006.4048,"size":75810,"hash":"4ba6437c735cf5a2546992968d1fcdfe5521a49d98f73ef37a383a6415befb25"},"images/shiro认证Authentication流程分析.png":{"mtime":1600517412008.3994,"size":161695,"hash":"521c41171f4eb343af532f2a6aaf34aeac163710eb37717b98f226d1f0165b57"},"images/SpringAOP五种通知执行顺序.png":{"mtime":1600444918641.8003,"size":67271,"hash":"c8039775cbcdd2100ec0ae3065f8d7c5f81a2071b6d2221cd58c60f95c5aaba7"},"images/SpringBoot启动后Bean的实例化过程.png":{"mtime":1600444918642.8008,"size":186307,"hash":"bccf754995135587321c35c637e845aaeb2d449794f3ffb6914067f05ad6d1f0"},"images/springboot启动过程分析.png":{"mtime":1600444918644.7927,"size":60738,"hash":"39798effe525e7c91cdfe1f54679ea05e33f3b09c821d9a9a2cc9a64c1f86cf3"},"images/springMVC请求路径图解.jpg":{"mtime":1600444918644.7927,"size":67112,"hash":"40132d576ab237541305cf1a2523cc2d1b71fb63e6db48aed9205b09dbc7d735"},"images/ThreadPoolExecutor相关getter方法.png":{"mtime":1600444918642.8008,"size":29003,"hash":"d2e028bcaa9eaf0d2bb2a508af7b1c33ba6c6ba5b56fb8f141344f3fecd31f33"},"images/ThreadPoolExecutor相关setter方法.png":{"mtime":1600444918642.8008,"size":17596,"hash":"acd7c8b467797116d361b9dded429458d36e69c44c4b05ce0f0c305b1a342677"},"images/ThreadPoolExecutor运行流程.png":{"mtime":1600444918643.7603,"size":52985,"hash":"988171f30e8c8ee2430a4e407d560cd36e6e83c5bd98888fb077ab538c862fd8"},"images/threadpool五种状态间转换.png":{"mtime":1600444918645.7551,"size":47233,"hash":"873911a23c6b0423d7d960b505ec941266298f696c603dd49675d958a4e07e29"},"images/原生JS Ajax.PNG":{"mtime":1600444918645.7551,"size":8341,"hash":"737db09e5380945c4149b27137f1f5db0257aff13cb85406cdb24d0c427f352a"},"images/新生代老年代.png":{"mtime":1600444918646.752,"size":47895,"hash":"ab60461cbf9dceda5f1a69e13a5a64b3a4ae01a2a0fc75122b5971439a2f5e1c"},"images/浮点数运算问题.png":{"mtime":1600444918646.752,"size":96116,"hash":"48591db9cd426e8341b46d17049230c75be4177c2144a6d3d2ff2519270447dc"},"images/线程池阻塞策略.png":{"mtime":1600444918649.7434,"size":387219,"hash":"6cfb3708a1015eab435ca3ecbd074e837363635e820eac4171595daec81f5098"},"images/线程的基本状态.png":{"mtime":1600444918650.741,"size":45756,"hash":"10b88841d77dfeddf746085102b93ceb70720df3179c034d13b67b96955632e7"},"NOTE/AOP(Aspect Orient Programming).md":{"mtime":1600635412930.6355,"size":1898,"hash":"c02cf053c29a494bdb138b1a92d6e69275c620e48443b1fd15829ead6fe1699a"},"NOTE/HTTP.md":{"mtime":1600444918637.8115,"size":67,"hash":"4d1a3a821ea83f47e92509252c29a233c51270b12166695558a3b5230808c982"},"NOTE/JavaScript.md":{"mtime":1600444918638.8103,"size":5184,"hash":"ae95be395624a23208017930eb99e57a58c4286c8a607d0fd756e657ba77910a"},"NOTE/JAVA基础.md":{"mtime":1600444918637.8115,"size":1903,"hash":"e768e4ee99dd24c4ca4e3763cf217c584e2353cc6743020e50b7e8e1b7fc92e5"},"NOTE/JVM.md":{"mtime":1600517412003.4424,"size":3117,"hash":"baff366a84279290758b1d89d418ee611c638f7974320102b3de0c7c6d4bd1a9"},"NOTE/List、Map、Set、Queue 总结.md":{"mtime":1600444918638.8103,"size":359,"hash":"c4803717ded15128b4a43b6e58caacac7e1541f3d1ddef800d933a150b8df058"},"NOTE/LRU.md":{"mtime":1600517412003.4424,"size":108,"hash":"06b0e8c809ff68b1ae59f714738ad94ca1c8a2e0b851d84fd26d21a751dd3c5b"},"NOTE/MYSQL.md":{"mtime":1600444918638.8103,"size":51,"hash":"91b1b2f7547f4ca886f3eb970c2c41ca4c2dfcf4880a924b6f5152c3121cf693"},"NOTE/shiro.md":{"mtime":1600635781092.024,"size":2960,"hash":"6faa1debef227ae74aba94d3d39e33aebe1ab2d0f6a7d2cf4d0e8ae6564740d7"},"NOTE/SpringBoot.md":{"mtime":1600517412003.4424,"size":2893,"hash":"31dd3411e568e90ae8fc3e987212d11f02bd4a49c540c6f5159155cc95543c47"},"NOTE/SqlSession.md":{"mtime":1600444918638.8103,"size":0,"hash":"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"},"NOTE/Transactional.md":{"mtime":1600517412003.4424,"size":4435,"hash":"a1a5e944f001d5131c61b1ff64ea834bc5d9c6b3d481f843520587a46cbfc933"},"NOTE/参考链接.md":{"mtime":1600635407824.8303,"size":1081,"hash":"21085afa419442cef7efc18ed91030eacd2302f4ddea19abcaa49c5ac8e0abd3"},"NOTE/基本算法.md":{"mtime":1600444918639.8054,"size":261,"hash":"e299036da769a6c04df9ea60ded1cfea98317b2a65f85408a37d2ef5c52b5c02"},"NOTE/多线程.md":{"mtime":1600444918639.8054,"size":5094,"hash":"3b404683af921954b28160c07107359f2b3542da888a124d17211d8076256f0d"},"NOTE/线程池.md":{"mtime":1600444918639.8054,"size":6946,"hash":"4ba3687c3b4769871cd0911be33d0d12dd0d0666c7e1bf58862aab02d87360b5"},"NOTE/设计模式.md":{"mtime":1600444918639.8054,"size":27,"hash":"26c15e460b0f764910050064bb0be57fa7f6279301b9191cd964b1f2edda9376"},"NOTE/锁.md":{"mtime":1600517412004.41,"size":915,"hash":"938e03d5d5a52162aa00614ce9bb903f3af52f3740fe1904f633cd634b4aac3d"},"Restaurant Online Ordering System.md":{"mtime":1600635406093.2285,"size":1229,"hash":"79344e55a29383419c658196da3460d12f54a1eb1b0ca2dbb3875b9ccc4c75e4"}},"metadata":{"da529ea4d3d0416918d143f25b6865531a1199787297508d0ceb049c32f1cb5e":{"links":[],"embeds":[],"tags":[],"headings":[]},"b15d00672b34f6236cd0f209485b71f06e7e8806822a4f0c8dc60d59c35efd42":{"links":[],"embeds":[],"tags":[],"headings":[]},"5d54081b4e75d0f4bdc49534028c287761e58239ba8c81654c2c33296e0e6727":{"links":[],"embeds":[],"tags":[],"headings":[]},"562f220865ea6ea0fc35864ee7fbab7495a3f8b24fd1b20fe136c3274347cc78":{"links":[],"embeds":[],"tags":[],"headings":[]},"0e36384505456f5978a5167ad995d243cf8f9086dc4cd1f310deec5e24688ea0":{"links":[],"embeds":[],"tags":[],"headings":[]},"4ba6437c735cf5a2546992968d1fcdfe5521a49d98f73ef37a383a6415befb25":{"links":[],"embeds":[],"tags":[],"headings":[]},"521c41171f4eb343af532f2a6aaf34aeac163710eb37717b98f226d1f0165b57":{"links":[],"embeds":[],"tags":[],"headings":[]},"c8039775cbcdd2100ec0ae3065f8d7c5f81a2071b6d2221cd58c60f95c5aaba7":{"links":[],"embeds":[],"tags":[],"headings":[]},"bccf754995135587321c35c637e845aaeb2d449794f3ffb6914067f05ad6d1f0":{"links":[],"embeds":[],"tags":[],"headings":[]},"39798effe525e7c91cdfe1f54679ea05e33f3b09c821d9a9a2cc9a64c1f86cf3":{"links":[],"embeds":[],"tags":[],"headings":[]},"40132d576ab237541305cf1a2523cc2d1b71fb63e6db48aed9205b09dbc7d735":{"links":[],"embeds":[],"tags":[],"headings":[]},"d2e028bcaa9eaf0d2bb2a508af7b1c33ba6c6ba5b56fb8f141344f3fecd31f33":{"links":[],"embeds":[],"tags":[],"headings":[]},"acd7c8b467797116d361b9dded429458d36e69c44c4b05ce0f0c305b1a342677":{"links":[],"embeds":[],"tags":[],"headings":[]},"988171f30e8c8ee2430a4e407d560cd36e6e83c5bd98888fb077ab538c862fd8":{"links":[],"embeds":[],"tags":[],"headings":[]},"873911a23c6b0423d7d960b505ec941266298f696c603dd49675d958a4e07e29":{"links":[],"embeds":[],"tags":[],"headings":[]},"737db09e5380945c4149b27137f1f5db0257aff13cb85406cdb24d0c427f352a":{"links":[],"embeds":[],"tags":[],"headings":[]},"ab60461cbf9dceda5f1a69e13a5a64b3a4ae01a2a0fc75122b5971439a2f5e1c":{"links":[],"embeds":[],"tags":[],"headings":[]},"48591db9cd426e8341b46d17049230c75be4177c2144a6d3d2ff2519270447dc":{"links":[],"embeds":[],"tags":[],"headings":[]},"6cfb3708a1015eab435ca3ecbd074e837363635e820eac4171595daec81f5098":{"links":[],"embeds":[],"tags":[],"headings":[]},"10b88841d77dfeddf746085102b93ceb70720df3179c034d13b67b96955632e7":{"links":[],"embeds":[],"tags":[],"headings":[]},"b23dc0cd4f357bba51ba860d3fc77994d923aaccaf8344de86172e7a7a62c653":{"links":[],"embeds":[{"line":32,"link":"SpringAOP五种通知执行顺序.png","original":"![[SpringAOP五种通知执行顺序.png]]","beforeContext":"@AfterThrowingafter之后程序出现异常则执行此通知 ","afterContext":""}],"tags":[],"headings":[{"line":0,"heading":"什么是AOP？","level":3},{"line":2,"heading":"Spring AOP","level":3}]},"4d1a3a821ea83f47e92509252c29a233c51270b12166695558a3b5230808c982":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"请求行","level":3},{"line":2,"heading":"请求头","level":3},{"line":4,"heading":"空行","level":3},{"line":6,"heading":"请求体","level":3}]},"ae95be395624a23208017930eb99e57a58c4286c8a607d0fd756e657ba77910a":{"links":[{"line":150,"link":"HTTP#请求体","original":"[[HTTP#请求体|请求体]]","displayText":"请求体","beforeContext":"关于前后端数据传递，FormData与RequestPayload<br>简单来说，参数为对象时，","afterContext":"内为RequestPayload；参数为字符串时，为FormData；但在最后提交请求时，RequestPayload会对非字符串做字符串转换"},{"line":161,"link":"SpringBoot#springMVC","original":"[[SpringBoot#springMVC|springMVC]]","displayText":"springMVC","beforeContext":"后端如何取到值？如果以Json形式，后端需要解析Json格式，如果以字符串形式传递，后端需要分割字符串在","afterContext":"中，如果参数为Object(实际为Json字符串传递)，@RequestBody 注解可以自动解析为对应 对象。"}],"embeds":[],"tags":[],"headings":[]},"e768e4ee99dd24c4ca4e3763cf217c584e2353cc6743020e50b7e8e1b7fc92e5":{"links":[{"line":50,"link":"线程池","original":"[[线程池]]","displayText":"","beforeContext":"","afterContext":""}],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"Java基础","level":1}]},"baff366a84279290758b1d89d418ee611c638f7974320102b3de0c7c6d4bd1a9":{"links":[{"line":30,"link":"JVM#方法区 Method Area","original":"[[JVM#方法区 Method Area|方法区]]","displayText":"方法区","beforeContext":"堆内存可以细分为 新生代(Young Generation)、老年代(Old Generation)，新生代又能细分为**伊甸区(Eden)和两个幸存者区(From Survivor，To Survivor**)。如下图：图中 **永久代(Permanent Generation)是Hotspot虚拟机特有的概念，是Hotspot把GC分代扩展至了方法区，是对","afterContext":"**的一种实现，别的JVM都没有。"}],"embeds":[{"line":1,"link":"JVM内存区域划分.png","original":"![[JVM内存区域划分.png]]","beforeContext":"<JDK1.7以前>","afterContext":""},{"line":30,"link":"新生代老年代.png","original":"![[新生代老年代.png]]","beforeContext":"堆内存可以细分为 新生代(Young Generation)、老年代(Old Generation)，新生代又能细分为**伊甸区(Eden)和两个幸存者区(From Survivor，To Survivor**)。如下图：","afterContext":"图中 **永久代(Permanent Generation)是Hotspot虚拟机特有的概念，是Hotspot把GC分代扩展至了方法区，是对方法区**的一种实现，别的JVM都没有。"},{"line":40,"link":"jdk1.8后内存区域图.jpg","original":"![[jdk1.8后内存区域图.jpg]]","beforeContext":"jdk1.8中就不再有方法区了，Hotspot对方法区的实现为，元空间Metaspace元空间不再与堆连续，而且是存在于本地内存（Native memory),所以不会再有类似永久代中的java.lang.OutOfMemoryError: PermGen space错误.<JDK1.8后>","afterContext":""}],"tags":[],"headings":[{"line":0,"heading":"JVM内存区域划分","level":2},{"line":5,"heading":"程序计数器(Program Counter Register)","level":3},{"line":12,"heading":"栈(Java virtual Machine Stacks)","level":3},{"line":19,"heading":"本地方法栈(Native Method Stack)","level":3},{"line":26,"heading":"堆(Heap)","level":3},{"line":35,"heading":"方法区(Method Area)","level":3},{"line":47,"heading":"JVM垃圾回收","level":1},{"line":64,"heading":"JVM调优","level":1}]},"c4803717ded15128b4a43b6e58caacac7e1541f3d1ddef800d933a150b8df058":{"links":[],"embeds":[],"tags":[],"headings":[]},"06b0e8c809ff68b1ae59f714738ad94ca1c8a2e0b851d84fd26d21a751dd3c5b":{"links":[],"embeds":[],"tags":[],"headings":[]},"91b1b2f7547f4ca886f3eb970c2c41ca4c2dfcf4880a924b6f5152c3121cf693":{"links":[],"embeds":[],"tags":[],"headings":[]},"7a94fb731c0ffe018ab15509642e6c14006a70acd0d9ca2e10b0c2adc3ffcf76":{"links":[],"embeds":[{"line":1,"link":"shiro核心对象.png","original":"![[shiro核心对象.png]]","beforeContext":"是Apache旗下一个开源安全框架http://shiro.apache.org/http://shiro.apache.org/核心对象,主要包括:认证管理对象,授权管理对象,会话管理对象,缓存管理对象,加密管理对象以及Realm管理对象(领域对象:负责处理认证和授权领域的数据访问题)等","afterContext":"Subject :主体对象，负责提交用户认证和授权信息。SecurityManager：安全管理器，负责认证，授权等业务实现。Realm：领域对象，负责从数据层获取业务数据。"},{"line":53,"link":"shiro认证Authentication流程分析.png","original":"![[shiro认证Authentication流程分析.png]]","beforeContext":"Authenticator 对realm返回的信息进行身份认证。","afterContext":""},{"line":61,"link":"shiro授权Authorization流程分析.png","original":"![[shiro授权Authorization流程分析.png]]","beforeContext":"Authorizer对用户授权信息进行判定。","afterContext":""}],"tags":[],"headings":[{"line":0,"heading":"shiro是什么？","level":3},{"line":10,"heading":"shiro配置","level":3},{"line":48,"heading":"认证(Authentication)流程分析如下:","level":3},{"line":56,"heading":"授权(Authorization)流程分析如下：","level":3}]},"31dd3411e568e90ae8fc3e987212d11f02bd4a49c540c6f5159155cc95543c47":{"links":[{"line":62,"link":"Transactional","original":"[[Transactional|Transactional]]","displayText":"","beforeContext":"事务 ","afterContext":""},{"line":83,"link":"#springboot","original":"[[#springboot]]","displayText":"","beforeContext":"CommandLineRunner 此接口定义了一种规范，可以在spring框架初始化以后执行一些逻辑。实现ComandLineRunner重写run方法，可以获取spring容器中的一些初始化资源","afterContext":""}],"embeds":[{"line":13,"link":"springboot启动过程分析.png","original":"![[springboot启动过程分析.png]]","beforeContext":"springboot启动过程分析","afterContext":""},{"line":28,"link":"SpringBoot启动后Bean的实例化过程.png","original":"![[SpringBoot启动后Bean的实例化过程.png]]","beforeContext":"SpringBoot启动后Bean的实例化过程","afterContext":""},{"line":63,"link":"Transactional#Spring中事务管理","original":"![[Transactional#Spring中事务管理]]","beforeContext":"","afterContext":""},{"line":68,"link":"springMVC请求路径图解.jpg","original":"![[springMVC请求路径图解.jpg]]","beforeContext":"springMVC请求路径图解","afterContext":""}],"tags":[],"headings":[{"line":0,"heading":"SPRINGBOOT","level":1},{"line":2,"heading":"springboot","level":2},{"line":4,"heading":"springboot有哪些关键特性","level":3},{"line":11,"heading":"springboot项目启动时发生了什么？","level":3},{"line":27,"heading":"spring管理Bean对象","level":3},{"line":53,"heading":"hikariCP","level":2},{"line":60,"heading":"spring","level":2},{"line":62,"heading":"事务 [[Transactional|Transactional]]","level":3},{"line":66,"heading":"springMVC","level":2},{"line":70,"heading":"mybatis","level":2}]},"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855":{"links":[],"embeds":[],"tags":[],"headings":[]},"a1a5e944f001d5131c61b1ff64ea834bc5d9c6b3d481f843520587a46cbfc933":{"links":[{"line":16,"link":"MYSQL","original":"[[MYSQL]]","displayText":"","beforeContext":"repeatable read可重复复读，这是","afterContext":"的默认级别，就是每次读取结果都一样，但是有可能产生幻读。"},{"line":19,"link":"锁","original":"[[锁]]","displayText":"","beforeContext":"serializable串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和","afterContext":"竞争的问题。"},{"line":36,"link":"SpringBoot","original":"[[SpringBoot]]","displayText":"","beforeContext":"在","afterContext":"项目中,其内部提供了事务的自动配置，当我们在项目中添加了指定依赖spring-boot-starter-jdbc时，框架会自动为我们的项目注入事务管理器对象，最常用的为DataSourceTransactionManager对象。"}],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"定义","level":3},{"line":5,"heading":"事务特性 ACID","level":3},{"line":24,"heading":"那ACID靠什么保证的呢？","level":3},{"line":35,"heading":"Spring中事务管理","level":3},{"line":55,"heading":"事务失效","level":3}]},"a1ca589267070a258376ad026d7f61e421defaa802eecf01407fdded173a1b7f":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"已读","level":4},{"line":3,"heading":"[5千字的SpringMVC总结，我觉得你会需要的](https://juejin.im/post/6869370008997380104)","level":4},{"line":5,"heading":"[MySQL数据库之互联网常用分库分表方案](https://www.cnblogs.com/littlecharacter/p/9342129.html)","level":4},{"line":7,"heading":"[深入理解线程池](http://www.ideabuffer.cn/2017/04/04/深入理解Java线程池：ThreadPoolExecutor/)","level":4},{"line":8,"heading":"[Java线程池实现原理及其在美团业务中的实践](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)","level":4},{"line":11,"heading":"未读","level":4}]},"e299036da769a6c04df9ea60ded1cfea98317b2a65f85408a37d2ef5c52b5c02":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"几种基本的排序算法","level":1},{"line":2,"heading":"插入排序","level":2},{"line":4,"heading":"直接插入排序","level":3},{"line":6,"heading":"希尔排序","level":3},{"line":9,"heading":"选择排序","level":2},{"line":11,"heading":"简单选择排序","level":3},{"line":13,"heading":"堆排序","level":3},{"line":16,"heading":"交换排序","level":2},{"line":18,"heading":"冒泡排序","level":3},{"line":20,"heading":"快速排序","level":3},{"line":23,"heading":"归并排序","level":2},{"line":26,"heading":"基数排序","level":2}]},"3b404683af921954b28160c07107359f2b3542da888a124d17211d8076256f0d":{"links":[{"line":6,"link":"JVM","original":"[[JVM]]","displayText":"","beforeContext":"等待阻塞：\t运行running 的线程执行 wait() 方法，","afterContext":"会将该线程放入等待队列wait queue"},{"line":9,"link":"锁","original":"[[锁]]","displayText":"","beforeContext":"同步阻塞： 运行(running)的线程获取","afterContext":" synchronized 时，若该锁被别的线程占用,则JVM会把该线程放入锁池(lock pool)中"},{"line":65,"link":"锁","original":"[[锁]]","displayText":"","beforeContext":"死","afterContext":""},{"line":78,"link":"线程池#","original":"[[线程池#]]","displayText":"","beforeContext":"对于软件资源限制，使用资源池","afterContext":"，对资源复用"}],"embeds":[{"line":13,"link":"线程的基本状态.png","original":"![[线程的基本状态.png]]","beforeContext":"状态间转换图示：","afterContext":""}],"tags":[],"headings":[{"line":0,"heading":"线程","level":2},{"line":1,"heading":"线程的基本状态","level":3},{"line":15,"heading":"*synchronized*","level":3},{"line":22,"heading":"*Lock*","level":3},{"line":24,"heading":"Lock实现类 **ReentrantLock**(排他锁,同一时刻只允许一个线程访问)","level":4},{"line":38,"heading":"*volatile*","level":3},{"line":45,"heading":"*ThreadLocal*","level":3},{"line":50,"heading":"*多线程开发常见问题：*","level":3}]},"4ba3687c3b4769871cd0911be33d0d12dd0d0666c7e1bf58862aab02d87360b5":{"links":[{"line":2,"link":"多线程","original":"[[多线程]]","displayText":"","beforeContext":"线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在","afterContext":"服务器中，如MYSQL。"},{"line":2,"link":"MYSQL","original":"[[MYSQL]]","displayText":"","beforeContext":"线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如","afterContext":"。"},{"line":108,"link":"参考链接#深入理解线程池 http www ideabuffer cn 2017 04 04 深入理解Java线程池：ThreadPoolExecutor","original":"[[参考链接#深入理解线程池 http www ideabuffer cn 2017 04 04 深入理解Java线程池：ThreadPoolExecutor|深入理解线程池]]","displayText":"深入理解线程池","beforeContext":"","afterContext":"Java线程池实现原理及其在美团业务中的实践"},{"line":108,"link":"参考链接#Java线程池实现原理及其在美团业务中的实践 https tech meituan com 2020 04 02 java-pooling-pratice-in-meituan html","original":"[[参考链接#Java线程池实现原理及其在美团业务中的实践 https tech meituan com 2020 04 02 java-pooling-pratice-in-meituan html|Java线程池实现原理及其在美团业务中的实践]]","displayText":"Java线程池实现原理及其在美团业务中的实践","beforeContext":"深入理解线程池","afterContext":""}],"embeds":[{"line":11,"link":"Executor及其实现类.PNG","original":"![[Executor及其实现类.PNG]]","beforeContext":"","afterContext":""},{"line":11,"link":"ThreadPoolExecutor运行流程.png","original":"![[ThreadPoolExecutor运行流程.png]]","beforeContext":"","afterContext":""},{"line":41,"link":"threadpool五种状态间转换.png","original":"![[threadpool五种状态间转换.png]]","beforeContext":"TERMINATED:terminated()方法进入该状态。状态间转换可以参见下图：","afterContext":""},{"line":90,"link":"execute方法执行流程图.png","original":"![[execute方法执行流程图.png]]","beforeContext":"如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常流程图如下：","afterContext":""},{"line":93,"link":"ThreadPoolExecutor相关getter方法.png","original":"![[ThreadPoolExecutor相关getter方法.png]]","beforeContext":"线程池监控ThreadPoolExecutor提供了public的getter方法，可以读取到当前线程池的运行状态以及参数，如下图所示：","afterContext":""},{"line":96,"link":"ThreadPoolExecutor相关setter方法.png","original":"![[ThreadPoolExecutor相关setter方法.png]]","beforeContext":"动态化线程池同样的，ThreadPoolExecutor也提供了几种public的setter方法，在线程池运行期可以动态的设置线程池相关参数","afterContext":""}],"tags":[],"headings":[{"line":1,"heading":"线程池","level":1},{"line":3,"heading":"为什么需要线程池？","level":2},{"line":10,"heading":"ThreadPoolExecutor","level":3},{"line":107,"heading":"参考链接","level":2}]},"26c15e460b0f764910050064bb0be57fa7f6279301b9191cd964b1f2edda9376":{"links":[{"line":0,"link":"JavaScript","original":"[[JavaScript|单例模式]]","displayText":"单例模式","beforeContext":"","afterContext":""}],"embeds":[],"tags":[],"headings":[]},"938e03d5d5a52162aa00614ce9bb903f3af52f3740fe1904f633cd634b4aac3d":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"CAS (Compare and swap)","level":2},{"line":7,"heading":"CAS优点:","level":4},{"line":11,"heading":"使用乐观锁(CAS)还是悲观锁(synchronized)","level":3}]},"aafc92d45c9d73007d6f1f7078ed14b1dcbbf6316b81e196a21e2b9ac957d29f":{"links":[{"line":26,"link":"shiro","original":"[[shiro]]","displayText":"","beforeContext":"SpringBoot + ","afterContext":" + mybatis + mysql + thymeleaf + …"}],"embeds":[],"tags":[],"headings":[]},"79344e55a29383419c658196da3460d12f54a1eb1b0ca2dbb3875b9ccc4c75e4":{"links":[{"line":26,"link":"shiro","original":"[[shiro]]","displayText":"","beforeContext":"SpringBoot + ","afterContext":" + mybatis + mysql + thymeleaf + …"}],"embeds":[],"tags":[],"headings":[]},"21085afa419442cef7efc18ed91030eacd2302f4ddea19abcaa49c5ac8e0abd3":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"已读","level":4},{"line":3,"heading":"[5千字的SpringMVC总结，我觉得你会需要的](https://juejin.im/post/6869370008997380104)","level":4},{"line":5,"heading":"[MySQL数据库之互联网常用分库分表方案](https://www.cnblogs.com/littlecharacter/p/9342129.html)","level":4},{"line":7,"heading":"[深入理解线程池](http://www.ideabuffer.cn/2017/04/04/深入理解Java线程池：ThreadPoolExecutor/)","level":4},{"line":8,"heading":"[Java线程池实现原理及其在美团业务中的实践](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)","level":4},{"line":11,"heading":"未读","level":4}]},"c02cf053c29a494bdb138b1a92d6e69275c620e48443b1fd15829ead6fe1699a":{"links":[],"embeds":[{"line":32,"link":"SpringAOP五种通知执行顺序.png","original":"![[SpringAOP五种通知执行顺序.png]]","beforeContext":"@AfterThrowingafter之后程序出现异常则执行此通知 ","afterContext":""}],"tags":[],"headings":[{"line":0,"heading":"什么是AOP？","level":3},{"line":2,"heading":"Spring AOP","level":3}]},"6faa1debef227ae74aba94d3d39e33aebe1ab2d0f6a7d2cf4d0e8ae6564740d7":{"links":[],"embeds":[{"line":1,"link":"shiro核心对象.png","original":"![[shiro核心对象.png]]","beforeContext":"是Apache旗下一个开源安全框架http://shiro.apache.org/http://shiro.apache.org/核心对象,主要包括:认证管理对象,授权管理对象,会话管理对象,缓存管理对象,加密管理对象以及Realm管理对象(领域对象:负责处理认证和授权领域的数据访问题)等","afterContext":"Subject :主体对象，负责提交用户认证和授权信息。SecurityManager：安全管理器，负责认证，授权等业务实现。Realm：领域对象，负责从数据层获取业务数据。"},{"line":53,"link":"shiro认证Authentication流程分析.png","original":"![[shiro认证Authentication流程分析.png]]","beforeContext":"Authenticator 对realm返回的信息进行身份认证。","afterContext":""},{"line":61,"link":"shiro授权Authorization流程分析.png","original":"![[shiro授权Authorization流程分析.png]]","beforeContext":"Authorizer对用户授权信息进行判定。","afterContext":""}],"tags":[],"headings":[{"line":0,"heading":"shiro是什么？","level":3},{"line":10,"heading":"shiro配置","level":3},{"line":48,"heading":"认证(Authentication)流程分析如下:","level":3},{"line":56,"heading":"授权(Authorization)流程分析如下：","level":3}]}},"algorithmVersion":9}